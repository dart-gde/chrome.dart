        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>SyncFileSystem class / chrome.sync_file_system Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="chrome.sync_file_system" data-type="SyncFileSystem">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../chrome.sync_file_system.html">chrome.sync_file_system</a> &rsaquo; <a href="../chrome.sync_file_system/SyncFileSystem.html">SyncFileSystem</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>SyncFileSystem</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>Use the chrome.syncFileSystem API to save and synchronize data on Google
Drive. This API is NOT for accessing arbitrary user docs stored in Google
Drive. It provides app-specific syncable storage for offline and caching
usage so that the same data can be available across different clients.</p>
<p>The 'syncFileSystem' permission is required.</p>
<p>Valid values for FileStatus are: 'synced', 'pending', and 'conflicting'.
Valid values for ConflictResolutionPolicy are: 'last<em>write</em>win' and 'manual'.</p>
<pre class="source">
class SyncFileSystem {
 SyncFileSystem._();

 /**
  * Returns a syncable filesystem backed by Google Drive. The returned
  * DOMFileSystem instance can be operated on in the same way as the Temporary
  * and Persistant file systems (see http://www.w3.org/TR/file-system-api/).
  * Calling this multiple times from the same app will return the same handle
  * to the same file system.
  *
  * see [chrome.FileSystem]
  */
 Future&lt;FileSystem&gt; requestFileSystem() {
   ChromeCompleter&lt;FileSystem&gt; completer = new ChromeCompleter.oneArg(FileSystem.createFrom);
   chromeProxy.syncFileSystem.requestFileSystem(completer.callback);
   return completer.future;
 }

 /**
  * Sets the default conflict resolution policy for the 'syncable' file storage
  * for the app. By default it is set to 'last_write_win'. When conflict
  * resolution policy is set to 'last_write_win' conflicts for existing files
  * are automatically resolved next time the file is updated. |callback| can be
  * optionally given to know if the request has succeeded or not.
  */
 void setConflictResolutionPolicy(String policy) {
   // TODO: support the optional success callback
   // the callback indicated has no parameters - how to tell whether a call
   // means success or failure?
   chromeProxy.syncFileSystem.setConflictResolutionPolicy(policy);
 }

 /**
  * Gets the current conflict resolution policy.
  */
 Future&lt;String&gt; getConflictResolutionPolicy() {
   ChromeCompleter&lt;String&gt; completer = new ChromeCompleter.oneArg();
   chromeProxy.syncFileSystem.getConflictResolutionPolicy(completer.callback);
   return completer.future;
 }

 /**
  * Returns the current usage and quota in bytes for the 'syncable' file
  * storage for the app.
  */
 Future&lt;UsageAndQuota&gt; getUsageAndQuota(FileSystem fileSystem) {
   ChromeCompleter&lt;UsageAndQuota&gt; completer = new ChromeCompleter.oneArg((var quota) {
     return new UsageAndQuota._(quota);
   });
   chromeProxy.syncFileSystem.getUsageAndQuota(fileSystem.proxy, completer.callback);
   return completer.future;
 }

 /**
  * Returns the FileStatus for the given fileEntry. The status value can be
  * 'synced', 'pending' or 'conflicting'. Note that 'conflicting' state only
  * happens when the service's conflict resolution policy is set to 'manual'.
  */
 Future&lt;String&gt; getFileStatus(FileEntry fileEntry) {
   ChromeCompleter&lt;String&gt; completer = new ChromeCompleter.oneArg();
   chromeProxy.syncFileSystem.getFileStatus(fileEntry.proxy, completer.callback);
   return completer.future;
 }

 /**
  * Returns each FileStatus for the given fileEntry array. Typically called
  * with the result from dirReader.readEntries().
  */
 Future&lt;List&lt;FileEntryStatus&gt;&gt; getFileStatuses(List&lt;FileEntry&gt; fileEntries) {
   ChromeCompleter&lt;List&lt;FileEntryStatus&gt;&gt; completer =
       new ChromeCompleter.oneArg((var proxy) {
         Iterable&lt;FileEntryStatus&gt; iter = listify(proxy).map(
             (proxy) =&gt; new FileEntryStatus._(proxy));
         return iter.toList();
       });
   List proxies = fileEntries.map((entry) =&gt; entry.proxy);
   chromeProxy.syncFileSystem.getFileStatuses(proxies, completer.callback);
   return completer.future;
 }

 final ChromeStreamController&lt;ServiceStatusEvent&gt; _onServiceStatusChanged =
     new ChromeStreamController&lt;ServiceStatusEvent&gt;.oneArg(
         () =&gt; chromeProxy.syncFileSystem.onServiceStatusChanged,
         (event) =&gt; new ServiceStatusEvent._(event));

 /**
  * Fired when an error or other status change has happened in the sync backend
  * (for example, when the sync is temporarily disabled due to network or
  * authentication error).
  */
 Stream&lt;ServiceStatusEvent&gt; get onServiceStatusChanged =&gt; _onServiceStatusChanged.stream;

 final ChromeStreamController&lt;FileStatusEvent&gt; _onFileStatusChanged =
     new ChromeStreamController&lt;FileStatusEvent&gt;.oneArg(
         () =&gt; chromeProxy.syncFileSystem.onFileStatusChanged,
         (event) =&gt; new FileStatusEvent._(event));

 /**
  * Fired when a file has been updated by the background sync service.
  */
 Stream&lt;FileStatusEvent&gt; get onFileStatusChanged =&gt; _onFileStatusChanged.stream;
}
</pre>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="onFileStatusChanged">
<button class="show-code">Code</button>
final Stream&lt;<a href="../chrome.sync_file_system/FileStatusEvent.html">FileStatusEvent</a>&gt;         <strong>onFileStatusChanged</strong> <a class="anchor-link"
            href="#onFileStatusChanged"
            title="Permalink to SyncFileSystem.onFileStatusChanged">#</a>
        </h4>
        <div class="doc">
<p>Fired when a file has been updated by the background sync service.</p>
<pre class="source">
Stream&lt;FileStatusEvent&gt; get onFileStatusChanged =&gt; _onFileStatusChanged.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onServiceStatusChanged">
<button class="show-code">Code</button>
final Stream&lt;<a href="../chrome.sync_file_system/ServiceStatusEvent.html">ServiceStatusEvent</a>&gt;         <strong>onServiceStatusChanged</strong> <a class="anchor-link"
            href="#onServiceStatusChanged"
            title="Permalink to SyncFileSystem.onServiceStatusChanged">#</a>
        </h4>
        <div class="doc">
<p>Fired when an error or other status change has happened in the sync backend
(for example, when the sync is temporarily disabled due to network or
authentication error).</p>
<pre class="source">
Stream&lt;ServiceStatusEvent&gt; get onServiceStatusChanged =&gt; _onServiceStatusChanged.stream;
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="getConflictResolutionPolicy">
<button class="show-code">Code</button>
Future&lt;String&gt; <strong>getConflictResolutionPolicy</strong>() <a class="anchor-link" href="#getConflictResolutionPolicy"
              title="Permalink to SyncFileSystem.getConflictResolutionPolicy">#</a></h4>
<div class="doc">
<p>Gets the current conflict resolution policy.</p>
<pre class="source">
Future&lt;String&gt; getConflictResolutionPolicy() {
 ChromeCompleter&lt;String&gt; completer = new ChromeCompleter.oneArg();
 chromeProxy.syncFileSystem.getConflictResolutionPolicy(completer.callback);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getFileStatus">
<button class="show-code">Code</button>
Future&lt;String&gt; <strong>getFileStatus</strong>(<a href="../chrome.files/FileEntry.html">FileEntry</a> fileEntry) <a class="anchor-link" href="#getFileStatus"
              title="Permalink to SyncFileSystem.getFileStatus">#</a></h4>
<div class="doc">
<p>Returns the FileStatus for the given fileEntry. The status value can be
'synced', 'pending' or 'conflicting'. Note that 'conflicting' state only
happens when the service's conflict resolution policy is set to 'manual'.</p>
<pre class="source">
Future&lt;String&gt; getFileStatus(FileEntry fileEntry) {
 ChromeCompleter&lt;String&gt; completer = new ChromeCompleter.oneArg();
 chromeProxy.syncFileSystem.getFileStatus(fileEntry.proxy, completer.callback);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getFileStatuses">
<button class="show-code">Code</button>
Future&lt;List&lt;<a href="../chrome.sync_file_system/FileEntryStatus.html">FileEntryStatus</a>&gt;&gt; <strong>getFileStatuses</strong>(List&lt;<a href="../chrome.files/FileEntry.html">FileEntry</a>&gt; fileEntries) <a class="anchor-link" href="#getFileStatuses"
              title="Permalink to SyncFileSystem.getFileStatuses">#</a></h4>
<div class="doc">
<p>Returns each FileStatus for the given fileEntry array. Typically called
with the result from dirReader.readEntries().</p>
<pre class="source">
Future&lt;List&lt;FileEntryStatus&gt;&gt; getFileStatuses(List&lt;FileEntry&gt; fileEntries) {
 ChromeCompleter&lt;List&lt;FileEntryStatus&gt;&gt; completer =
     new ChromeCompleter.oneArg((var proxy) {
       Iterable&lt;FileEntryStatus&gt; iter = listify(proxy).map(
           (proxy) =&gt; new FileEntryStatus._(proxy));
       return iter.toList();
     });
 List proxies = fileEntries.map((entry) =&gt; entry.proxy);
 chromeProxy.syncFileSystem.getFileStatuses(proxies, completer.callback);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getUsageAndQuota">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.sync_file_system/UsageAndQuota.html">UsageAndQuota</a>&gt; <strong>getUsageAndQuota</strong>(<a href="../chrome.files/FileSystem.html">FileSystem</a> fileSystem) <a class="anchor-link" href="#getUsageAndQuota"
              title="Permalink to SyncFileSystem.getUsageAndQuota">#</a></h4>
<div class="doc">
<p>Returns the current usage and quota in bytes for the 'syncable' file
storage for the app.</p>
<pre class="source">
Future&lt;UsageAndQuota&gt; getUsageAndQuota(FileSystem fileSystem) {
 ChromeCompleter&lt;UsageAndQuota&gt; completer = new ChromeCompleter.oneArg((var quota) {
   return new UsageAndQuota._(quota);
 });
 chromeProxy.syncFileSystem.getUsageAndQuota(fileSystem.proxy, completer.callback);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="requestFileSystem">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.files/FileSystem.html">FileSystem</a>&gt; <strong>requestFileSystem</strong>() <a class="anchor-link" href="#requestFileSystem"
              title="Permalink to SyncFileSystem.requestFileSystem">#</a></h4>
<div class="doc">
<p>Returns a syncable filesystem backed by Google Drive. The returned
DOMFileSystem instance can be operated on in the same way as the Temporary
and Persistant file systems (see http://www.w3.org/TR/file-system-api/).
Calling this multiple times from the same app will return the same handle
to the same file system.</p>
<p>see <code>chrome.FileSystem</code></p>
<pre class="source">
Future&lt;FileSystem&gt; requestFileSystem() {
 ChromeCompleter&lt;FileSystem&gt; completer = new ChromeCompleter.oneArg(FileSystem.createFrom);
 chromeProxy.syncFileSystem.requestFileSystem(completer.callback);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="setConflictResolutionPolicy">
<button class="show-code">Code</button>
void <strong>setConflictResolutionPolicy</strong>(String policy) <a class="anchor-link" href="#setConflictResolutionPolicy"
              title="Permalink to SyncFileSystem.setConflictResolutionPolicy">#</a></h4>
<div class="doc">
<p>Sets the default conflict resolution policy for the 'syncable' file storage
for the app. By default it is set to 'last<em>write</em>win'. When conflict
resolution policy is set to 'last<em>write</em>win' conflicts for existing files
are automatically resolved next time the file is updated. |callback| can be
optionally given to know if the request has succeeded or not.</p>
<pre class="source">
void setConflictResolutionPolicy(String policy) {
 // TODO: support the optional success callback
 // the callback indicated has no parameters - how to tell whether a call
 // means success or failure?
 chromeProxy.syncFileSystem.setConflictResolutionPolicy(policy);
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-09-18 19:52:45.328</div>
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
