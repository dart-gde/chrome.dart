/* This file has been generated - do not edit */

library chrome.enterprise;

import '../src/common.dart';

final ChromeEnterprise enterprise = new ChromeEnterprise._();

class ChromeEnterprise {
  ChromeEnterprise._();

  /**
   * Accessor for the `chrome.enterprise.deviceAttributes` namespace.
   */
  final ChromeEnterpriseDeviceAttributes deviceAttributes = new ChromeEnterpriseDeviceAttributes._();

  /**
   * Accessor for the `chrome.enterprise.platformKeys` namespace.
   */
  final ChromeEnterprisePlatformKeys platformKeys = new ChromeEnterprisePlatformKeys._();
}

/**
 * Use the `chrome.enterprise.deviceAttributes` API to read device attributes.
 */
class ChromeEnterpriseDeviceAttributes extends ChromeApi {
  JsObject get _enterprise_deviceAttributes => chrome['enterprise']['deviceAttributes'];

  ChromeEnterpriseDeviceAttributes._();

  bool get available => _enterprise_deviceAttributes != null;

  /**
   * Fetches the value of <a
   * href="https://developers.google.com/admin-sdk/directory/v1/guides/manage-chrome-devices">the
   * device identifier of the directory API</a>, that is generated by the server
   * and identifies the cloud record of the device for querying in the cloud
   * directory API.
   * [callback]: Called with the device identifier of the directory API when
   * received.
   */
  Future<String> getDirectoryDeviceId() {
    if (_enterprise_deviceAttributes == null) _throwNotAvailable();

    var completer = new ChromeCompleter<String>.oneArg();
    _enterprise_deviceAttributes.callMethod('getDirectoryDeviceId', [completer.callback]);
    return completer.future;
  }

  void _throwNotAvailable() {
    throw new UnsupportedError("'chrome.enterprise.deviceAttributes' is not available");
  }
}

/**
 * Use the `chrome.enterprise.platformKeys` API to generate hardware-backed keys
 * and to install certificates for these keys. The certificates will be managed
 * by the platform and can be used for TLS authentication, network access or by
 * other extension through $(ref:platformKeys chrome.platformKeys).
 */
class ChromeEnterprisePlatformKeys extends ChromeApi {
  JsObject get _enterprise_platformKeys => chrome['enterprise']['platformKeys'];

  ChromeEnterprisePlatformKeys._();

  bool get available => _enterprise_platformKeys != null;

  /**
   * Returns the available Tokens. In a regular user's session the list will
   * always contain the user's token with `id` `"user"`. If a system-wide TPM
   * token is available, the returned list will also contain the system-wide
   * token with `id` `"system"`. The system-wide token will be the same for all
   * sessions on this device (device in the sense of e.g. a Chromebook).
   * 
   * Returns:
   * Invoked by `getTokens` with the list of available Tokens.
   * [tokens]: The list of available tokens.
   */
  Future<List<Token>> getTokens() {
    if (_enterprise_platformKeys == null) _throwNotAvailable();

    var completer = new ChromeCompleter<List<Token>>.oneArg((e) => listify(e, _createToken));
    _enterprise_platformKeys.callMethod('getTokens', [completer.callback]);
    return completer.future;
  }

  /**
   * Returns the list of all client certificates available from the given token.
   * Can be used to check for the existence and expiration of client
   * certificates that are usable for a certain authentication.
   * [tokenId]: The id of a Token returned by `getTokens`.
   * [callback]: Called back with the list of the available certificates.
   * 
   * Returns:
   * Callback to which the certificates are passed.
   * [certificates]: The list of certificates, each in DER encoding of a X.509
   * certificate.
   */
  Future<List<ArrayBuffer>> getCertificates(String tokenId) {
    if (_enterprise_platformKeys == null) _throwNotAvailable();

    var completer = new ChromeCompleter<List<ArrayBuffer>>.oneArg((e) => listify(e, _createArrayBuffer));
    _enterprise_platformKeys.callMethod('getCertificates', [tokenId, completer.callback]);
    return completer.future;
  }

  /**
   * Imports `certificate` to the given token if the certified key is already
   * stored in this token. After a successful certification request, this
   * function should be used to store the obtained certificate and to make it
   * available to the operating system and browser for authentication.
   * [tokenId]: The id of a Token returned by `getTokens`.
   * [certificate]: The DER encoding of a X.509 certificate.
   * [callback]: Called back when this operation is finished.
   */
  Future importCertificate(String tokenId, ArrayBuffer certificate) {
    if (_enterprise_platformKeys == null) _throwNotAvailable();

    var completer = new ChromeCompleter.noArgs();
    _enterprise_platformKeys.callMethod('importCertificate', [tokenId, jsify(certificate), completer.callback]);
    return completer.future;
  }

  /**
   * Removes `certificate` from the given token if present. Should be used to
   * remove obsolete certificates so that they are not considered during
   * authentication and do not clutter the certificate choice. Should be used to
   * free storage in the certificate store.
   * [tokenId]: The id of a Token returned by `getTokens`.
   * [certificate]: The DER encoding of a X.509 certificate.
   * [callback]: Called back when this operation is finished.
   */
  Future removeCertificate(String tokenId, ArrayBuffer certificate) {
    if (_enterprise_platformKeys == null) _throwNotAvailable();

    var completer = new ChromeCompleter.noArgs();
    _enterprise_platformKeys.callMethod('removeCertificate', [tokenId, jsify(certificate), completer.callback]);
    return completer.future;
  }

  /**
   * Challenges a hardware-backed Enterprise Machine Key and emits the response
   * as part of a remote attestation protocol. Only useful on Chrome OS and in
   * conjunction with the Verified Access Web API which both issues challenges
   * and verifies responses. A successful verification by the Verified Access
   * Web API is a strong signal of all of the following: * The current device is
   * a legitimate Chrome OS device. * The current device is managed by the
   * domain specified during verification. * The current signed-in user is
   * managed by the domain specified during verification. * The current device
   * state complies with enterprise device policy. For example, a policy may
   * specify that the device must not be in developer mode. * Any device
   * identity emitted by the verification is tightly bound to the hardware of
   * the current device. This function is highly restricted and will fail if the
   * current device is not managed, the current user is not managed, or if this
   * operation has not explicitly been enabled for the caller by enterprise
   * device policy. The Enterprise Machine Key does not reside in the `"system"`
   * token and is not accessible by any other API.
   * [challenge]: A challenge as emitted by the Verified Access Web API.
   * [callback]: Called back with the challenge response.
   * 
   * Returns:
   * Invoked by `challengeMachineKey` or `challengeUserKey` with the challenge
   * response.
   * [response]: The challenge response.
   */
  Future<ArrayBuffer> challengeMachineKey(ArrayBuffer challenge) {
    if (_enterprise_platformKeys == null) _throwNotAvailable();

    var completer = new ChromeCompleter<ArrayBuffer>.oneArg(_createArrayBuffer);
    _enterprise_platformKeys.callMethod('challengeMachineKey', [jsify(challenge), completer.callback]);
    return completer.future;
  }

  /**
   * Challenges a hardware-backed Enterprise User Key and emits the response as
   * part of a remote attestation protocol. Only useful on Chrome OS and in
   * conjunction with the Verified Access Web API which both issues challenges
   * and verifies responses. A successful verification by the Verified Access
   * Web API is a strong signal of all of the following: * The current device is
   * a legitimate Chrome OS device. * The current device is managed by the
   * domain specified during verification. * The current signed-in user is
   * managed by the domain specified during verification. * The current device
   * state complies with enterprise user policy. For example, a policy may
   * specify that the device must not be in developer mode. * The public key
   * emitted by the verification is tightly bound to the hardware of the current
   * device and to the current signed-in user. This function is highly
   * restricted and will fail if the current device is not managed, the current
   * user is not managed, or if this operation has not explicitly been enabled
   * for the caller by enterprise user policy. The Enterprise User Key does not
   * reside in the `"user"` token and is not accessible by any other API.
   * [challenge]: A challenge as emitted by the Verified Access Web API.
   * [registerKey]: If set, the current Enterprise User Key is registered with
   * the `"user"` token and relinquishes the Enterprise User Key role. The key
   * can then be associated with a certificate and used like any other signing
   * key. This key is 2048-bit RSA. Subsequent calls to this function will then
   * generate a new Enterprise User Key.
   * [callback]: Called back with the challenge response.
   * 
   * Returns:
   * Invoked by `challengeMachineKey` or `challengeUserKey` with the challenge
   * response.
   * [response]: The challenge response.
   */
  Future<ArrayBuffer> challengeUserKey(ArrayBuffer challenge, bool registerKey) {
    if (_enterprise_platformKeys == null) _throwNotAvailable();

    var completer = new ChromeCompleter<ArrayBuffer>.oneArg(_createArrayBuffer);
    _enterprise_platformKeys.callMethod('challengeUserKey', [jsify(challenge), registerKey, completer.callback]);
    return completer.future;
  }

  void _throwNotAvailable() {
    throw new UnsupportedError("'chrome.enterprise.platformKeys' is not available");
  }
}

class Token extends ChromeObject {
  Token({String id, SubtleCrypto subtleCrypto}) {
    if (id != null) this.id = id;
    if (subtleCrypto != null) this.subtleCrypto = subtleCrypto;
  }
  Token.fromProxy(JsObject jsProxy): super.fromProxy(jsProxy);

  String get id => jsProxy['id'];
  set id(String value) => jsProxy['id'] = value;

  SubtleCrypto get subtleCrypto => _createSubtleCrypto(jsProxy['subtleCrypto']);
  set subtleCrypto(SubtleCrypto value) => jsProxy['subtleCrypto'] = jsify(value);
}

Token _createToken(JsObject jsProxy) => jsProxy == null ? null : new Token.fromProxy(jsProxy);
ArrayBuffer _createArrayBuffer(/*JsObject*/ jsProxy) => jsProxy == null ? null : new ArrayBuffer.fromProxy(jsProxy);
SubtleCrypto _createSubtleCrypto(JsObject jsProxy) => jsProxy == null ? null : new SubtleCrypto.fromProxy(jsProxy);
